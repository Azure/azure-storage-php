<html>
    <head>
        <script
            type="text/javascript"
            src="../../../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

/**
 * LICENSE: The MIT License (the &quot;License&quot;)
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * https://github.com/azure/azure-storage-php/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * PHP version 5
 *
 * @category  Microsoft
 * @package   MicrosoftAzure\Storage\Common\Internal
 * @author    Azure Storage PHP SDK &lt;dmsh@microsoft.com&gt;
 * @copyright 2016 Microsoft Corporation
 * @license   https://github.com/azure/azure-storage-php/LICENSE
 * @link      https://github.com/azure/azure-storage-php
 */

namespace MicrosoftAzure\Storage\Common\Internal;

/**
 * Helper methods for parsing connection strings. The rules for formatting connection
 * strings are defined here:
 * www.connectionstrings.com/articles/show/important-rules-for-connection-strings
 *
 * @ignore
 * @category  Microsoft
 * @package   MicrosoftAzure\Storage\Common\Internal
 * @author    Azure Storage PHP SDK &lt;dmsh@microsoft.com&gt;
 * @copyright 2016 Microsoft Corporation
 * @license   https://github.com/azure/azure-storage-php/LICENSE
 * @link      https://github.com/azure/azure-storage-php
 */
class ConnectionStringParser
{
    const EXPECT_KEY        = 'ExpectKey';
    const EXPECT_ASSIGNMENT = 'ExpectAssignment';
    const EXPECT_VALUE      = 'ExpectValue';
    const EXPECT_SEPARATOR  = 'ExpectSeparator';

    private $_argumentName;
    private $_value;
    private $_pos;
    private $_state;

    /**
     * Parses the connection string into a collection of key/value pairs.
     *
     * @param string $argumentName     Name of the argument to be used in error
     * messages.
     * @param string $connectionString Connection string.
     *
     * @return array
     */
    public static function parseConnectionString($argumentName, $connectionString)
    {
        Validate::canCastAsString($argumentName, 'argumentName');
        Validate::notNullOrEmpty($argumentName, 'argumentName');
        Validate::canCastAsString($connectionString, 'connectionString');
        Validate::notNullOrEmpty($connectionString, 'connectionString');

        $parser = new ConnectionStringParser($argumentName, $connectionString);
        return $parser-&gt;_parse();
    }

    /**
     * Initializes the object.
     *
     * @param string $argumentName Name of the argument to be used in error
     * messages.
     * @param string $value        Connection string.
     */
    private function __construct($argumentName, $value)
    {
        $this-&gt;_argumentName = $argumentName;
        $this-&gt;_value        = $value;
        $this-&gt;_pos          = 0;
        $this-&gt;_state        = ConnectionStringParser::EXPECT_KEY;
    }

    /**
     * Parses the connection string.
     *
     * @return array
     *
     * @throws \RuntimeException
     */
    private function _parse()
    {
        $key                    = null;
        $value                  = null;
        $connectionStringValues = array();

        while (true) {
            $this-&gt;_skipWhiteSpaces();

            if ($this-&gt;_pos == strlen($this-&gt;_value)
                &amp;&amp; $this-&gt;_state != ConnectionStringParser::EXPECT_VALUE
            ) {
                // Not stopping after the end has been reached and a value is
                // expected results in creating an empty value, which we expect.
                break;
            }

            switch ($this-&gt;_state) {
                case ConnectionStringParser::EXPECT_KEY:
                    $key          = $this-&gt;_extractKey();
                    $this-&gt;_state = ConnectionStringParser::EXPECT_ASSIGNMENT;
                    break;

                case ConnectionStringParser::EXPECT_ASSIGNMENT:
                    $this-&gt;_skipOperator('=');
                    $this-&gt;_state = ConnectionStringParser::EXPECT_VALUE;
                    break;

                case ConnectionStringParser::EXPECT_VALUE:
                    $value                        = $this-&gt;_extractValue();
                    $this-&gt;_state                 =
                    ConnectionStringParser::EXPECT_SEPARATOR;
                    $connectionStringValues[$key] = $value;
                    $key                          = null;
                    $value                        = null;
                    break;

                default:
                    $this-&gt;_skipOperator(';');
                    $this-&gt;_state = ConnectionStringParser::EXPECT_KEY;
                    break;
            }
        }

        // Must end parsing in the valid state (expected key or separator)
        if ($this-&gt;_state == ConnectionStringParser::EXPECT_ASSIGNMENT) {
            throw $this-&gt;_createException(
                $this-&gt;_pos,
                Resources::MISSING_CONNECTION_STRING_CHAR,
                '='
            );
        }

        return $connectionStringValues;
    }

    /**
     *Generates an invalid connection string exception with the detailed error
     * message.
     *
     * @param integer $position    The position of the error.
     * @param string  $errorString The short error formatting string.
     *
     * @return \RuntimeException
     */
    private function _createException($position, $errorString)
    {
        $arguments = func_get_args();

        // Remove first and second arguments (position and error string)
        unset($arguments[0], $arguments[1]);

        // Create a short error message.
        $errorString = vsprintf($errorString, $arguments);

        // Add position.
        $errorString = sprintf(
            Resources::ERROR_PARSING_STRING,
            $errorString,
            $position
        );

        // Create final error message.
        $errorString = sprintf(
            Resources::INVALID_CONNECTION_STRING,
            $this-&gt;_argumentName,
            $errorString
        );

        return new \RuntimeException($errorString);
    }

    /**
     * Skips whitespaces at the current position.
     *
     * @return void
     */
    private function _skipWhiteSpaces()
    {
        while ($this-&gt;_pos &lt; strlen($this-&gt;_value)
              &amp;&amp;  ctype_space($this-&gt;_value[$this-&gt;_pos])
        ) {
            $this-&gt;_pos++;
        }
    }

    /**
     * Extracts the key's value.
     *
     * @return string
     */
    private function _extractValue()
    {
        $value = Resources::EMPTY_STRING;

        if ($this-&gt;_pos &lt; strlen($this-&gt;_value)) {
            $ch = $this-&gt;_value[$this-&gt;_pos];

            if ($ch == '&quot;' || $ch == '\'') {
                // Value is contained between double quotes or skipped single quotes.
                $this-&gt;_pos++;
                $value = $this-&gt;_extractString($ch);
            } else {
                $firstPos = $this-&gt;_pos;
                $isFound  = false;

                while ($this-&gt;_pos &lt; strlen($this-&gt;_value) &amp;&amp; !$isFound) {
                    $ch = $this-&gt;_value[$this-&gt;_pos];

                    if ($ch == ';') {
                        $isFound = true;
                    } else {
                        $this-&gt;_pos++;
                    }
                }

                $value = rtrim(
                    substr($this-&gt;_value, $firstPos, $this-&gt;_pos - $firstPos)
                );
            }
        }

        return $value;
    }

    /**
     * Extracts key at the current position.
     *
     * @return string
     */
    private function _extractKey()
    {
        $key      = null;
        $firstPos = $this-&gt;_pos;
        $ch       = $this-&gt;_value[$this-&gt;_pos];

        if ($ch == '&quot;' || $ch == '\'') {
            $this-&gt;_pos++;
            $key = $this-&gt;_extractString($ch);
        } elseif ($ch == ';' || $ch == '=') {
            // Key name was expected.
            throw $this-&gt;_createException(
                $firstPos,
                Resources::ERROR_CONNECTION_STRING_MISSING_KEY
            );
        } else {
            while ($this-&gt;_pos &lt; strlen($this-&gt;_value)) {
                $ch = $this-&gt;_value[$this-&gt;_pos];

                // At this point we've read the key, break.
                if ($ch == '=') {
                    break;
                }

                $this-&gt;_pos++;
            }
            $key = rtrim(substr($this-&gt;_value, $firstPos, $this-&gt;_pos - $firstPos));
        }

        if (strlen($key) == 0) {
            // Empty key name.
            throw $this-&gt;_createException(
                $firstPos,
                Resources::ERROR_CONNECTION_STRING_EMPTY_KEY
            );
        }

        return $key;
    }

    /**
     * Extracts the string until the given quotation mark.
     *
     * @param string $quote The quotation mark terminating the string.
     *
     * @return string
     */
    private function _extractString($quote)
    {
        $firstPos = $this-&gt;_pos;

        while ($this-&gt;_pos &lt; strlen($this-&gt;_value)
              &amp;&amp;  $this-&gt;_value[$this-&gt;_pos] != $quote
        ) {
            $this-&gt;_pos++;
        }

        if ($this-&gt;_pos == strlen($this-&gt;_value)) {
            // Runaway string.
            throw $this-&gt;_createException(
                $this-&gt;_pos,
                Resources::ERROR_CONNECTION_STRING_MISSING_CHARACTER,
                $quote
            );
        }

        return substr($this-&gt;_value, $firstPos, $this-&gt;_pos++ - $firstPos);
    }

    /**
     * Skips specified operator.
     *
     * @param string $operatorChar The operator character.
     *
     * @return void
     *
     * @throws \RuntimeException
     */
    private function _skipOperator($operatorChar)
    {
        if ($this-&gt;_value[$this-&gt;_pos] != $operatorChar) {
            // Character was expected.
            throw $this-&gt;_createException(
                $this-&gt;_pos,
                Resources::MISSING_CONNECTION_STRING_CHAR,
                $operatorChar
            );
        }

        $this-&gt;_pos++;
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>